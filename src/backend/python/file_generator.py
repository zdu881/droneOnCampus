#!/usr/bin/env python3
"""
文件生成工具模块
用于创建指定大小的示例文件
"""

import os
import hashlib
import random
import string
from pathlib import Path
from typing import Union, Dict, Any


def generate_file_content(size_bytes: int, content_type: str = "text") -> bytes:
    """
    生成指定大小的文件内容
    
    Args:
        size_bytes: 文件大小（字节）
        content_type: 内容类型 ("text", "random", "pattern")
    
    Returns:
        生成的文件内容（字节）
    """
    if content_type == "text":
        return _generate_text_content(size_bytes)
    elif content_type == "random":
        return _generate_random_content(size_bytes)
    elif content_type == "pattern":
        return _generate_pattern_content(size_bytes)
    else:
        return _generate_text_content(size_bytes)


def _generate_text_content(size_bytes: int) -> bytes:
    """生成文本内容"""
    # 生成重复的文本内容
    base_text = "This is a sample file generated by CastRay for testing purposes. " \
                "The content repeats to reach the specified file size. " \
                "Line number: {}\n"
    
    content = []
    current_size = 0
    line_num = 1
    
    while current_size < size_bytes:
        line = base_text.format(line_num)
        line_bytes = line.encode('utf-8')
        
        if current_size + len(line_bytes) > size_bytes:
            # 截断最后一行以达到精确大小
            remaining = size_bytes - current_size
            content.append(line_bytes[:remaining])
            break
        else:
            content.append(line_bytes)
            current_size += len(line_bytes)
            line_num += 1
    
    return b''.join(content)


def _generate_random_content(size_bytes: int) -> bytes:
    """生成随机内容"""
    return bytes(random.getrandbits(8) for _ in range(size_bytes))


def _generate_pattern_content(size_bytes: int) -> bytes:
    """生成有规律的模式内容"""
    # 生成重复的字节模式
    pattern = b'0123456789ABCDEF' * 64  # 1KB 的模式
    full_patterns = size_bytes // len(pattern)
    remainder = size_bytes % len(pattern)
    
    content = pattern * full_patterns
    if remainder > 0:
        content += pattern[:remainder]
    
    return content


def create_sample_file(file_path: Union[str, Path], size_bytes: int, 
                      content_type: str = "text", 
                      include_metadata: bool = True) -> Dict[str, Any]:
    """
    创建指定大小的示例文件
    
    Args:
        file_path: 文件路径
        size_bytes: 文件大小（字节）
        content_type: 内容类型 ("text", "random", "pattern")
        include_metadata: 是否包含元数据
    
    Returns:
        文件信息字典
    """
    file_path = Path(file_path)
    
    # 确保目录存在
    file_path.parent.mkdir(parents=True, exist_ok=True)
    
    # 生成文件内容
    content = generate_file_content(size_bytes, content_type)
    
    # 写入文件
    with open(file_path, 'wb') as f:
        f.write(content)
    
    # 计算文件信息
    actual_size = file_path.stat().st_size
    file_hash = hashlib.md5(content).hexdigest()
    
    file_info = {
        "file_path": str(file_path.absolute()),
        "file_name": file_path.name,
        "requested_size": size_bytes,
        "actual_size": actual_size,
        "content_type": content_type,
        "md5_hash": file_hash,
        "created": True
    }
    
    if include_metadata:
        # 添加文件头部信息
        metadata_header = _create_metadata_header(file_info)
        
        # 重新写入文件，包含元数据
        with open(file_path, 'wb') as f:
            f.write(metadata_header)
            f.write(content)
        
        # 更新实际大小
        file_info["actual_size"] = file_path.stat().st_size
        file_info["includes_metadata"] = True
    
    return file_info


def _create_metadata_header(file_info: Dict[str, Any]) -> bytes:
    """创建文件元数据头部"""
    metadata = f"""# CastRay Generated File Metadata
# File: {file_info['file_name']}
# Requested Size: {file_info['requested_size']} bytes
# Content Type: {file_info['content_type']}
# Generated: {file_info.get('created_time', 'Unknown')}
# MD5 Hash: {file_info['md5_hash']}
# --- Content Starts Below ---

"""
    return metadata.encode('utf-8')


def parse_size_string(size_str: str) -> int:
    """
    解析大小字符串为字节数
    
    支持的格式:
    - "100B" 或 "100" -> 100 字节
    - "1KB" -> 1024 字节
    - "1MB" -> 1048576 字节
    - "1GB" -> 1073741824 字节
    
    Args:
        size_str: 大小字符串
    
    Returns:
        字节数
    """
    size_str = size_str.strip().upper()
    
    # 定义单位转换（按长度从长到短排序，避免匹配错误）
    units = [
        ('TB', 1024 * 1024 * 1024 * 1024),
        ('GB', 1024 * 1024 * 1024),
        ('MB', 1024 * 1024),
        ('KB', 1024),
        ('B', 1)
    ]
    
    # 检查每个单位
    for unit, multiplier in units:
        if size_str.endswith(unit):
            number_part = size_str[:-len(unit)].strip()
            try:
                number = float(number_part)
                if number < 0:
                    raise ValueError(f"Size cannot be negative: {size_str}")
                return int(number * multiplier)
            except ValueError as e:
                if "cannot be negative" in str(e):
                    raise
                raise ValueError(f"Invalid number in size format: {size_str}")
    
    # 如果没有单位，默认为字节
    try:
        number = float(size_str)
        if number < 0:
            raise ValueError(f"Size cannot be negative: {size_str}")
        return int(number)
    except ValueError:
        raise ValueError(f"Invalid size format: {size_str}")


def format_size(size_bytes: int) -> str:
    """
    格式化字节数为可读的大小字符串
    
    Args:
        size_bytes: 字节数
    
    Returns:
        格式化的大小字符串
    """
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.2f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024):.2f} MB"
    elif size_bytes < 1024 * 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024 * 1024):.2f} GB"
    else:
        return f"{size_bytes / (1024 * 1024 * 1024 * 1024):.2f} TB"


def validate_file_size(size_bytes: int, max_size: int = 1024 * 1024 * 1024) -> bool:
    """
    验证文件大小是否在允许范围内
    
    Args:
        size_bytes: 要验证的文件大小
        max_size: 最大允许大小（默认1GB）
    
    Returns:
        是否有效
    """
    return 0 < size_bytes <= max_size


def get_available_content_types() -> Dict[str, str]:
    """获取可用的内容类型"""
    return {
        "text": "可读文本内容（重复的文本行）",
        "random": "随机字节内容",
        "pattern": "重复的字节模式"
    }


# 预设的常用文件大小
PRESET_SIZES = {
    "tiny": 1024,          # 1KB
    "small": 10 * 1024,    # 10KB
    "medium": 100 * 1024,  # 100KB
    "large": 1024 * 1024,  # 1MB
    "huge": 10 * 1024 * 1024,  # 10MB
    "massive": 100 * 1024 * 1024  # 100MB
}


def create_preset_file(preset_name: str, file_path: Union[str, Path], 
                      content_type: str = "text") -> Dict[str, Any]:
    """
    创建预设大小的文件
    
    Args:
        preset_name: 预设名称 ("tiny", "small", "medium", "large", "huge", "massive")
        file_path: 文件路径
        content_type: 内容类型
    
    Returns:
        文件信息字典
    """
    if preset_name not in PRESET_SIZES:
        raise ValueError(f"Unknown preset: {preset_name}. Available: {list(PRESET_SIZES.keys())}")
    
    size_bytes = PRESET_SIZES[preset_name]
    return create_sample_file(file_path, size_bytes, content_type)


if __name__ == "__main__":
    # 测试功能
    import tempfile
    
    print("Testing file generation...")
    
    with tempfile.TemporaryDirectory() as temp_dir:
        # 测试不同大小的文件创建
        test_sizes = ["1KB", "10KB", "1MB"]
        
        for size_str in test_sizes:
            size_bytes = parse_size_string(size_str)
            file_path = Path(temp_dir) / f"test_{size_str.lower()}.txt"
            
            file_info = create_sample_file(file_path, size_bytes)
            print(f"Created {size_str} file: {file_info['file_name']}")
            print(f"  Actual size: {format_size(file_info['actual_size'])}")
            print(f"  MD5: {file_info['md5_hash']}")
            print()
